name: Publish Coco Website
defaults:
  run:
    shell: bash
env:
  TZ: Asia/Shanghai
  PNAME: coco-website
  NODEJS_VERSION: ${{ vars.NODEJS_EXT_VERSION }}

on:
  workflow_dispatch:
    inputs:
      PUBLISH_RELEASE:
        description: 'Publish Release'
        required: false
        type: boolean
        default: false

jobs:
  publish:
    name: Publish Coco Webisite
    runs-on: ubuntu-latest
    env:
        OSS_EP: ${{ secrets.OSS_EP }}
        OSS_AK: ${{ secrets.OSS_AK }}
        OSS_SK: ${{ secrets.OSS_SK }}
        OSS_BK: ${{ secrets.OSS_BK }}
        OSS_MODE: ${{ secrets.OSS_MODE }}
        LOCAL_HOST: ${{ secrets.LOCAL_HOST }}
        LOCAL_PORT: ${{ secrets.LOCAL_PORT }}
        SSH_GIT_REPO: ${{ secrets.SSH_GIT_REPO }}
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        SSH_CONFIG: ${{ secrets.SSH_CONFIG }}
        CONNECT_SERVER: ${{ secrets.CONNECT_SERVER }}
        CONNECT_PORT: ${{ secrets.CONNECT_PORT }}
        CONNECT_KEY: ${{ secrets.CONNECT_KEY }}
        CONNECT_TIMEOUT: ${{ vars.CONNECT_TIMEOUT }}
        CONNECT_MODE: ${{ vars.CONNECT_MODE }}
        CONNECT_METHOD: ${{ secrets.CONNECT_METHOD }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup bootstrap
      uses: ./containers/bootstrap

    - name: checkout coco website
      uses: actions/checkout@v4
      with:
        ref: main
        repository: infinilabs/${{ env.PNAME }}
        path: ${{ env.PNAME }}
    
    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        package_json_file: "${{ env.PNAME }}/package.json"

    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODEJS_VERSION }}
        cache: "pnpm"
  
    - name: Update data.json with latest versions and publish dates
      working-directory: ${{ env.PNAME }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -e

        DATA_JSON_PATH="public/data.json"

        echo "Fetching latest version info..."
        VERSION_INFO=$(curl -s --fail --max-time 10 https://release.infinilabs.com/.latest)
        APP_FULL_VERSION=$(echo "$VERSION_INFO" | jq -r '.["coco-app"]')
        SERVER_FULL_VERSION=$(echo "$VERSION_INFO" | jq -r '.["coco-server"]')

        echo "App Version: $APP_FULL_VERSION"
        echo "Server Version: $SERVER_FULL_VERSION"

        # Function to get the creation date of a Git tag (compact version)
        get_gh_tag_date() {
          local repo_slug="$1"
          local full_ver_from_latest="$2"
          
          # Extract version parts
          local xyz_part=$(echo "$full_ver_from_latest" | cut -d'-' -f1)
          local xy_part=$(echo "$xyz_part" | cut -d'.' -f1,2)
          
          # Tags to try, in order of preference
          local tag1="v${xyz_part}"
          local tag2="v${xy_part}.0"

          # Fetch all tags once, then process locally.
          # Using --paginate fetches all pages automatically.
          sleep 10
          local all_tags_json=$(gh api --paginate "/repos/${repo_slug}/tags")
          sleep 10
          # Use a single jq command to find the preferred tag and get its commit date
          local commit_sha=$(echo "$all_tags_json" | jq -r \
            --arg tag1 "$tag1" --arg tag2 "$tag2" \
            'map(select(.name == $tag1 or .name == $tag2)) | 
              sort_by(if .name == $tag1 then 0 else 1 end) | 
              .[0].commit.sha // empty')

          if [[ -n "$commit_sha" ]]; then
            # Get the commit date from the commit SHA
            gh api "/repos/${repo_slug}/commits/${commit_sha}" --jq '.commit.committer.date | split("T")[0]'
          else
            date +%Y-%m-%d
          fi
        }

        # Get dates using the compact function
        APP_DATE=$(get_gh_tag_date "infinilabs/coco-app" "$APP_FULL_VERSION")
        SERVER_DATE=$(get_gh_tag_date "infinilabs/coco-server" "$SERVER_FULL_VERSION")
        get_gh_publish_date() {
          local repo_slug="$1"  # e.g., infinilabs/coco-app
          local full_ver_from_latest="$2"   # e.g., 0.5.3-2323 (this is the version string from .latest)
          local date_val

          # Extract X.Y.Z part from the full version string
          local xyz_part=$(echo "$full_ver_from_latest" | cut -d'-' -f1) # e.g., 0.5.3

          # Construct the X.Y.0 part
          local xy_part=$(echo "$xyz_part" | cut -d'.' -f1,2) # e.g., 0.5
          local xyz_zero_patch_part="${xy_part}.0"            # e.g., 0.5.0

          local tag_attempt1="v${xyz_part}"                   # Primary attempt, e.g., v0.5.3
          local tag_attempt2="v${xyz_zero_patch_part}"        # Fallback, e.g., v0.5.0

          sleep 10
          # Attempt 1: X.Y.Z version tag (e.g., v0.5.3)
          date_val=$(curl "https://api.github.com/repos/${repo_slug}/releases/tags/${tag_attempt1}" | \
            jq -r '.created_at | split("T")[0 // empty]' 2>/dev/null)
          sleep 10
          # Attempt 2: X.Y.0 version tag (e.g., v0.5.0)
          if [[ -z "$date_val" || "$date_val" == "null" ]]; then
            date_val=$(curl "https://api.github.com/repos/${repo_slug}/releases/tags/${tag_attempt2}" | \
              jq -r '.created_at | split("T")[0 // empty]' 2>/dev/null)
          fi
          
          # Final fallback to current date
          if [[ -z "$date_val" || "$date_val" == "null" ]]; then
            date_val=$(date +%Y-%m-%d)
          fi
          echo "$date_val"
        }

        APP_PUBLISH_DATE=$(get_gh_publish_date "infinilabs/coco-app" "$APP_FULL_VERSION")
        SERVER_PUBLISH_DATE=$(get_gh_publish_date "infinilabs/coco-server" "$SERVER_FULL_VERSION")

        echo "App Date: $APP_DATE"
        echo "Server Date: $SERVER_DATE"

        # Update the data.json file using jq
        jq \
          --arg app_ver "$APP_FULL_VERSION" \
          --arg server_ver "$SERVER_FULL_VERSION" \
          --arg app_date "$APP_DATE" \
          --arg server_date "$SERVER_DATE" \
          '.app = $app_ver | .server = $server_ver | .app_publish = $app_date | .server_publish = $server_date' \
          "$DATA_JSON_PATH" > tmp_data.json && mv tmp_data.json "$DATA_JSON_PATH"

        echo -e "Updated $DATA_JSON_PATH\n"
        cat "$DATA_JSON_PATH"

    - name: Restore cache
      uses: actions/cache@v4
      with:
        path: |
          .next/cache
        key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json', '**/yarn.lock', '**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}
        restore-keys: |
          ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json', '**/yarn.lock', '**/pnpm-lock.yaml') }}

    - name: Install dependencies
      working-directory: ${{ env.PNAME }}
      run: pnpm install --registry=https://registry.npmjs.org --quiet

    - name: Build with Web
      working-directory: ${{ env.PNAME }}
      env:
        NODE_ENV: production
      run: pnpm build

    - name: Add CNAME file
      working-directory: ${{ env.PNAME }}
      run: echo "coco.rs" > ./docs/CNAME

    - name: Disable Jekyll
      working-directory: ${{ env.PNAME }}
      run: touch docs/.nojekyll

    - name: Check export directory
      working-directory: ${{ env.PNAME }}
      run: ls -la ./docs

    - name: Create zip archive
      working-directory: ${{ env.PNAME }}
      run: |
        ( cd docs && zip -r ../$PANME.zip . )
        ls -l $PANME.zip
    
    - name: Run connect in background for ${{env.PNAME}}
      run: |
        connect -c "$GITHUB_WORKSPACE/.oss.json" >/dev/null 2>&1 &
        echo "Connect started with pid $!"
        sleep 15

    - name: Deploy ${{env.PNAME}}
      timeout-minutes: 30
      continue-on-error: true
      working-directory: ${{ env.PNAME }}
      run: |
        if [[ -f $GITHUB_WORKSPACE/$PNAME.zip ]]; then
          echo "Deploying $PNAME to staging at $(date +'%m-%d %H:%M:%S')"
          scp -r $GITHUB_WORKSPACE/$PNAME.zip staging:/infini/demo-environment/$PNAME.zip
          echo "Uploaded $PNAME to staging at $(date +'%m-%d %H:%M:%S')"
          ssh staging 'bash -s' < $GITHUB_WORKSPACE/products/$PNAME/deploy.sh
        else
          echo "No $PNAME zip found"
        fi
        echo "Finished deploying $PNAME to staging at $(date +'%m-%d %H:%M:%S')"