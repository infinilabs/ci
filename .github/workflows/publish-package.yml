name: Publish Platform Package

on:
  workflow_dispatch:
    inputs:
      target_platform:
        description: 'Publish Platform (snapcraft, msstore, or all)'
        required: true
        type: choice
        options:
          - snapcraft
          - msstore
          - all
        default: snapcraft
      app_version:
        description: 'Application Version (e.g., 0.5.3)'
        required: true
        type: string
        default: '0.5.3'
      build_number:
        description: 'Build Number (e.g., 2323)'
        required: true
        type: string
        default: '2323'

env:
  RELEASE_BASE_URL: "https://release.infinilabs.com/coco/app/stable"
  APP_NAME_IN_FILENAME: "Coco-AI"

jobs:
  # ======================================================================
  # Job 1: Publish to Snap Store (Snapcraft)
  # ======================================================================
  publish-snapcraft:
    if: |
      github.event_name == 'workflow_dispatch' &&
      (github.event.inputs.target_platform == 'snapcraft' || github.event.inputs.target_platform == 'all')
    strategy:
      fail-fast: false
      matrix:
        snap_arch: [amd64, arm64]
    runs-on: ubuntu-latest
    env:
      APP_VERSION_BASE: ${{ github.event.inputs.app_version }}
      APP_BUILD_NUMBER: ${{ github.event.inputs.build_number }}
      APP_FULL_VERSION: "${{ github.event.inputs.app_version }}-${{ github.event.inputs.build_number }}"
    steps:
      - name: Checkout CI repository
        uses: actions/checkout@v4
      - name: Set Snap Architecture-Specific Variables
        id: snap_arch_vars
        run: |
          current_snap_arch="${{ matrix.snap_arch }}"
          download_suffix=""; friendly_name_text=""
          if [ "$current_snap_arch" == "amd64" ]; then download_suffix="-deb-linux-amd64.zip"; friendly_name_text="Snap Linux amd64";
          elif [ "$current_snap_arch" == "arm64" ]; then download_suffix="-deb-linux-arm64.zip"; friendly_name_text="Snap Linux arm64";
          else echo "Error: Unknown snap_arch: $current_snap_arch"; exit 1; fi
          echo "download_zip_suffix=${download_suffix}" >> $GITHUB_OUTPUT; echo "friendly_name=${friendly_name_text}" >> $GITHUB_OUTPUT
          full_version="${{ env.APP_FULL_VERSION }}"; base_version=$(echo "$full_version" | awk -F'-' '{print $1}'); if [ -z "$base_version" ]; then echo "Could not extract base version"; exit 1; fi
          echo "app_base_version=$base_version" >> $GITHUB_OUTPUT
        shell: bash
      - name: Download and Prepare .deb Artifact for Snap (${{ steps.snap_arch_vars.outputs.friendly_name }})
        id: download_deb_artifact
        run: |
          base_version_path=".v${{ steps.snap_arch_vars.outputs.app_base_version }}"
          ARTIFACT_ZIP_FILENAME="${{ env.APP_NAME_IN_FILENAME }}-${{ env.APP_FULL_VERSION }}${{ steps.snap_arch_vars.outputs.download_zip_suffix }}"
          DOWNLOAD_URL="${{ env.RELEASE_BASE_URL }}/${base_version_path}/${ARTIFACT_ZIP_FILENAME}"
          curl -fL -o "${ARTIFACT_ZIP_FILENAME}" "${DOWNLOAD_URL}"
          mkdir -p "./snap_payload_${{ matrix.snap_arch }}"; unzip -q "${ARTIFACT_ZIP_FILENAME}" -d "./snap_payload_${{ matrix.snap_arch }}"; rm "${ARTIFACT_ZIP_FILENAME}"
          DEB_FILE=$(find "./snap_payload_${{ matrix.snap_arch }}" -name "*.deb" -type f -print -quit)
          if [ -z "$DEB_FILE" ]; then echo "ERROR: No .deb file found"; exit 1; fi
          mkdir -p ./snap_sources; cp "${DEB_FILE}" "./snap_sources/app_${{ matrix.snap_arch }}.deb"
        shell: bash
      - name: Install Snapcraft
        run: sudo snap install snapcraft --classic
      - name: Build Snap package for ${{ matrix.snap_arch }}
        id: build_snap
        run: |
          if [ ! -f snap/snapcraft.yaml ]; then echo "ERROR: snap/snapcraft.yaml not found!"; exit 1; fi
          sed -i "s|^version:.*$|version: '${{ env.APP_FULL_VERSION }}'|" snap/snapcraft.yaml
          # Ensure snapcraft.yaml part source: $SNAPCRAFT_PROJECT_DIR/snap_sources/app_${SNAPCRAFT_TARGET_ARCH}.deb
          snapcraft pack --output "${{ env.APP_NAME_IN_FILENAME }}_${{ env.APP_FULL_VERSION }}_${{ matrix.snap_arch }}.snap"
          SNAP_FILE_PATH=$(ls *_${{ matrix.snap_arch }}.snap | head -n 1)
          if [ -z "$SNAP_FILE_PATH" ]; then echo "Error: No .snap file found"; exit 1; fi
          echo "snap_package_path=$SNAP_FILE_PATH" >> $GITHUB_OUTPUT
        shell: bash
      - name: Log in to Snapcraft
        env: SNAPCRAFT_LOGIN_FILE_CONTENT: ${{ secrets.SNAPCRAFT_LOGIN_FILE_CONTENT }}
        run: echo "${SNAPCRAFT_LOGIN_FILE_CONTENT}" > sc.login && snapcraft login --with sc.login && rm sc.login
        shell: bash
      - name: Push and Release Snap for ${{ matrix.snap_arch }}
        run: snapcraft push "${{ steps.build_snap.outputs.snap_package_path }}" --release stable
        shell: bash

  # ======================================================================
  # Microsoft Store Publishing - Single Job
  # ASSUMES: Packages (.exe installers or MSIX) are ALREADY hosted at public URLs.
  # ======================================================================
  publish-all-msstore-packages:
    if: |
      github.event_name == 'workflow_dispatch' &&
      (github.event.inputs.target_platform == 'msstore' || github.event.inputs.target_platform == 'all')
    runs-on: windows-latest
    env:
      APP_VERSION_BASE: ${{ github.event.inputs.app_version }} # e.g., 0.5.3
      APP_BUILD_NUMBER: ${{ github.event.inputs.build_number }} # e.g., 2323
      APP_FULL_VERSION: "${{ github.event.inputs.app_version }}-${{ github.event.inputs.build_number }}" # e.g., 0.5.3-2323
    steps:
      - name: Checkout CI repository (needed if AppxManifest.xml or other local config is used)
        uses: actions/checkout@v4

      # This step is now primarily for logging and constructing the JSON,
      # as the actual package files are assumed to be at pre-existing public URLs.
      - name: Prepare Submission Details
        id: prepare_submission_details
        run: |
          $baseVersionForUrlPath = ".v${{ env.APP_VERSION_BASE }}"
          $fullVersionForFilename = "${{ env.APP_FULL_VERSION }}"
          $appName = "${{ env.APP_NAME_IN_FILENAME }}"
          $baseUrl = "${{ env.RELEASE_BASE_URL }}"
          
          $packagesJson = @()
          
          # Define architectures and their corresponding filename/API identifiers
          $archMap = @{
            "X64"   = @{ filename_arch = "amd64" } # API Arch -> Filename Arch Suffix
            "ARM64" = @{ filename_arch = "arm64" }
            "X86"   = @{ filename_arch = "x86"   }
          }

          foreach ($apiArch in $archMap.Keys) {
            $fileNameArch = $archMap[$apiArch].filename_arch
            # Construct package filename: Coco-AI_0.5.3-2323_amd64-setup.exe
            $packageFileName = "${appName}_${fullVersionForFilename}_${fileNameArch}-setup.exe"
            # If you are submitting MSIX files, the filename and type would be different, e.g.:
            # $packageFileName = "${appName}_${fullVersionForFilename}_${apiArch}.msix" 
            
            $packagePublicUrl = "${baseUrl}/${baseVersionForUrlPath}/${packageFileName}"
            Write-Host "Package URL for $apiArch : $packagePublicUrl"
            
            $packagesJson += @{
              packageUrl = $packagePublicUrl 
              languages = @("en-us") # Defaulting to en-us
              architectures = @($apiArch) # X64, ARM64, X86 for the API
              isSilentInstall = $true    # Assuming -setup.exe supports silent install
              # If submitting MSIX, isSilentInstall might not be applicable or needed
            }
          }
          
          $productUpdatePayload = @{ packages = $packagesJson } | ConvertTo-Json -Depth 5 -Compress
          Write-Host "Product Update JSON Payload:"
          Write-Host $productUpdatePayload
          # Escape for multiline output
          $productUpdatePayloadForOutput = $productUpdatePayload -replace "`n","%0A" -replace "`r","%0D"
          echo "product_update_json=$productUpdatePayloadForOutput" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Configure Store Connection
        uses: microsoft/store-submission@v1
        with:
          command: configure
          type: win32 # Or 'msix' if your packageUrls point to MSIX files
          seller-id: ${{ secrets.PARTNER_CENTER_SELLER_ID }}
          product-id: ${{ secrets.MSSTORE_PRODUCT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Update Draft Submission with Packages
        uses: microsoft/store-submission@v1
        with:
          command: update
          product-update: ${{ steps.prepare_submission_details.outputs.product_update_json }}

      - name: Publish Submission
        uses: microsoft/store-submission@v1
        with:
          command: publish
          # Optional: Add --flight-id "your-flight-id" if publishing to a specific flight
          # Optional: Add --skip-polling true if you don't want the action to wait for completion