name: Publish Platform Package

on:
  workflow_dispatch:
    inputs:
      target_platform:
        description: 'Publish Platform (snapcraft, msstore, or all)'
        required: true
        type: choice
        options:
          - snapcraft
          - msstore
          - all
        default: all
      app_version:
        description: 'Application Version (e.g., 0.5.3)'
        required: true
        type: string
        default: '0.5.3'
      build_number:
        description: 'Build Number (e.g., 2323)'
        required: true
        type: string
        default: '2323'

env:
  RELEASE_BASE_URL: "https://release.infinilabs.com/coco/app/stable"
  APP_NAME_IN_FILENAME: "Coco-AI"

jobs:
  # ======================================================================
  # Job 1: Publish to Snap Store (Snapcraft)
  # ======================================================================
  publish-snapcraft:
    if: |
      github.event_name == 'workflow_dispatch' &&
      (github.event.inputs.target_platform == 'snapcraft' || github.event.inputs.target_platform == 'all')
    strategy:
      fail-fast: false
      matrix:
        include:
          - snap_arch: amd64
            runner: ubuntu-22.04
          - snap_arch: arm64
            runner: ubuntu-22.04-arm
    runs-on: ${{ matrix.runner }} 
    env:
      APP_VERSION_BASE: ${{ github.event.inputs.app_version }}
      APP_BUILD_NUMBER: ${{ github.event.inputs.build_number }}
      APP_FULL_VERSION: "${{ github.event.inputs.app_version }}-${{ github.event.inputs.build_number }}"
    steps:
      - name: Checkout CI repository
        uses: actions/checkout@v4

      - name: Set Snap Architecture-Specific Variables
        id: snap_arch_vars
        run: |
          current_snap_arch="${{ matrix.snap_arch }}"
          download_suffix=""; friendly_name_text=""
          if [ "$current_snap_arch" == "amd64" ]; then download_suffix="-deb-linux-amd64.zip"; friendly_name_text="Snap Linux amd64";
          elif [ "$current_snap_arch" == "arm64" ]; then download_suffix="-deb-linux-arm64.zip"; friendly_name_text="Snap Linux arm64";
          else echo "Error: Unknown snap_arch: $current_snap_arch"; exit 1; fi
          echo "download_zip_suffix=${download_suffix}" >> $GITHUB_OUTPUT; echo "friendly_name=${friendly_name_text}" >> $GITHUB_OUTPUT
          full_version="${{ env.APP_FULL_VERSION }}"; base_version=$(echo "$full_version" | awk -F'-' '{print $1}'); if [ -z "$base_version" ]; then echo "Could not extract base version"; exit 1; fi
          echo "app_base_version=$base_version" >> $GITHUB_OUTPUT
        shell: bash

      - name: Download and Prepare .deb Artifact for Snap (${{ steps.snap_arch_vars.outputs.friendly_name }})
        id: download_deb_artifact
        run: |
          echo "Downloading .deb artifact for ${{ matrix.snap_arch }} architecture"
          ARTIFACT_ZIP_FILENAME="${{ env.APP_NAME_IN_FILENAME }}-${{ env.APP_FULL_VERSION }}${{ steps.snap_arch_vars.outputs.download_zip_suffix }}"
          DOWNLOAD_URL="${{ env.RELEASE_BASE_URL }}/${ARTIFACT_ZIP_FILENAME}"
          curl -sfL -o "${ARTIFACT_ZIP_FILENAME}" "${DOWNLOAD_URL}"
          mkdir -p "snap_payload_${{ matrix.snap_arch }}"; unzip -q "${ARTIFACT_ZIP_FILENAME}" -d "snap_payload_${{ matrix.snap_arch }}"; rm "${ARTIFACT_ZIP_FILENAME}"
          DEB_FILE=$(find "snap_payload_${{ matrix.snap_arch }}" -name "*.deb" -type f -print -quit)
          if [ -z "$DEB_FILE" ]; then echo "ERROR: No .deb file found"; exit 1; fi
          echo "Found .deb file: $DEB_FILE"
          mkdir -p snap/sources; cp "${DEB_FILE}" "snap/sources/${{ env.APP_NAME_IN_FILENAME }}_${{ matrix.snap_arch }}.deb"
        shell: bash

      - name: Setup LXD
        uses: canonical/setup-lxd@main
        with:
          group: lxd
          channel: latest/stable

      - name: Add user to the LXD (lxd) group
        run: |
          sudo usermod -a -G lxd ${USER}
          newgrp lxd

      - name: Install Snapcraft
        run: sudo snap install snapcraft --classic

      - name: Generate snapcraft.yaml
        run: |
          mkdir -p snap/gui
          cp -rf $GITHUB_WORKSPACE/products/coco-app/coco-ai.png snap/gui
          cat > snap/snapcraft.yaml <<EOF
          name: coco-ai
          base: core22
          version: '${{ env.APP_FULL_VERSION }}'
          summary: Coco-AI
          icon: snap/gui/coco-ai.png
          contact: hello@infini.ltd
          license: MIT
          description: |
            ðŸ¥¥ Coco AI App - Search, Connect, Collaborate, Your Personal AI Search and Assistant, all in one space.
          grade: stable
          confinement: strict
          architectures:
            - ${{ matrix.snap_arch }} 
          apps:
            coco-ai:
              command: /usr/bin/coco
              plugs:
                - network
                - home
          parts:
            coco-ai:
              plugin: dump
              source: sources/${{ env.APP_NAME_IN_FILENAME }}_${{ matrix.snap_arch }}.deb
              source-type: deb
          EOF
          echo "Generated snap/snapcraft.yaml:"
          cat snap/snapcraft.yaml
        shell: bash

      - name: Build Snap package for ${{ matrix.snap_arch }}
        id: build_snap
        run: |
          snapcraft pack --output "${{ env.APP_NAME_IN_FILENAME }}_${{ env.APP_FULL_VERSION }}_${{ matrix.snap_arch }}.snap"
          SNAP_FILE_PATH=$(ls *_${{ matrix.snap_arch }}.snap | head -n 1)
          if [ -z "$SNAP_FILE_PATH" ]; then echo "Error: No .snap file found"; exit 1; fi
          echo "snap_package_path=$SNAP_FILE_PATH" >> $GITHUB_OUTPUT
        shell: bash

      - name: Log in to Snapcraft
        env: 
          SNAPCRAFT_LOGIN_FILE_CONTENT: ${{ secrets.SNAPCRAFT_LOGIN_FILE_CONTENT }}
        run: echo "${SNAPCRAFT_LOGIN_FILE_CONTENT}" > sc.login && snapcraft login --with sc.login && rm sc.login
        shell: bash

      - name: Push and Release Snap for ${{ matrix.snap_arch }}
        run: snapcraft push "${{ steps.build_snap.outputs.snap_package_path }}" --release stable
        shell: bash

  # ======================================================================
  # Microsoft Store Publishing - Single Job
  # ASSUMES: Packages (.exe installers or MSIX) are ALREADY hosted at public URLs.
  # ======================================================================
  publish-all-msstore-packages:
    if: |
      github.event_name == 'workflow_dispatch' &&
      (github.event.inputs.target_platform == 'msstore' || github.event.inputs.target_platform == 'all')
    runs-on: windows-latest
    env:
      APP_VERSION_BASE: ${{ github.event.inputs.app_version }}
      APP_BUILD_NUMBER: ${{ github.event.inputs.build_number }}
      APP_FULL_VERSION: "${{ github.event.inputs.app_version }}-${{ github.event.inputs.build_number }}"
    steps:
      - name: Checkout CI repository (needed if AppxManifest.xml or other local config is used)
        uses: actions/checkout@v4

      # This step is now primarily for logging and constructing the JSON,
      # as the actual package files are assumed to be at pre-existing public URLs.
      - name: Prepare Submission Details
        id: prepare_submission_details
        run: |
          $baseVersionForUrlPath = ".v${{ env.APP_VERSION_BASE }}"
          $fullVersionForFilename = "${{ env.APP_FULL_VERSION }}"
          $appName = "${{ env.APP_NAME_IN_FILENAME }}"
          $baseUrl = "${{ env.RELEASE_BASE_URL }}"
          
          $packagesJson = @()
          
          # Define architectures and their corresponding filename/API identifiers
          $archMap = @{
            "X64"   = @{ filename_arch = "amd64" }
            "ARM64" = @{ filename_arch = "arm64" }
            "X86"   = @{ filename_arch = "x86"   }
          }

          foreach ($apiArch in $archMap.Keys) {
            $fileNameArch = $archMap[$apiArch].filename_arch
            # Construct package filename: Coco-AI_0.5.3-2323_amd64-setup.exe
            $packageFileName = "${appName}_${fullVersionForFilename}_${fileNameArch}-setup.exe"
            # If you are submitting MSIX files, the filename and type would be different, e.g.:
            # $packageFileName = "${appName}_${fullVersionForFilename}_${apiArch}.msix" 
            
            $packagePublicUrl = "${baseUrl}/${baseVersionForUrlPath}/${packageFileName}"
            Write-Host "Package URL for $apiArch : $packagePublicUrl"
            
            $packagesJson += @{
              packageUrl = $packagePublicUrl 
              languages = @("en-us") # Defaulting to en-us
              architectures = @($apiArch) # X64, ARM64, X86 for the API
              isSilentInstall = $true    # Assuming -setup.exe supports silent install
              # If submitting MSIX, isSilentInstall might not be applicable or needed
            }
          }
          
          $productUpdatePayload = @{ packages = $packagesJson } | ConvertTo-Json -Depth 5 -Compress
          Write-Host "Product Update JSON Payload:"
          Write-Host $productUpdatePayload
          # Escape for multiline output
          $productUpdatePayloadForOutput = $productUpdatePayload -replace "`n","%0A" -replace "`r","%0D"
          echo "product_update_json=$productUpdatePayloadForOutput" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: pwsh

      - name: Configure Store Connection
        uses: microsoft/store-submission@v1
        with:
          command: configure
          type: win32
          seller-id: ${{ secrets.PARTNER_CENTER_SELLER_ID }}
          product-id: ${{ secrets.MSSTORE_PRODUCT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Update Draft Submission with Packages
        uses: microsoft/store-submission@v1
        with:
          command: update
          product-update: ${{ steps.prepare_submission_details.outputs.product_update_json }}

      - name: Publish Submission
        uses: microsoft/store-submission@v1
        with:
          command: publish
          # Optional: Add --flight-id "your-flight-id" if publishing to a specific flight
          # Optional: Add --skip-polling true if you don't want the action to wait for completion